1:试着不用var
2:使用无副作用的函数（比如返回值不要为Unit） 例如 def printAll(args:Array[String]) args.foreach(println)，测试时需要重定义print检查打印结果的正确性，
而def printAll(args:Array[String]) args.mkString('\n'),返回String对象，可以在调用函数处打印，直接在外部函数对返回值进行断言即可测试，方便单元测试
3：字符字面量感觉可以被字符串字面量平替？暂时不知道它的价值。
4：任何操作数都是方法，任何方法也可以是操作数，前缀操作数的方法名为"unary_"+操作数（只支持!+-~），中缀操作数和后缀操作数方法名都是操作数本身。
5：注意隐式转换的作用域，哪里要转换哪里声名？
6：:paste进入编译模式，可以用IDEA的控制台开启解释器
7：赋值语句返回值为Unit
8:finally的return可以覆盖try里面的return,但非显式return不覆盖try的返回
9:for的条件可以用花括号代替小括号，花括号中的变量不会离开花括号后就消失（意识到是条件部分还挺显而易见）
10:子语句块开头的{似乎被认为是不能作为语句开始的词，所以根据分号推断机制，当它作为一行开头时，上一行的结尾必须加上分号
11：函数式编程：函数是头等值，函数无副作用
12:函数字面量，(x:Int,y:Int)=>x+y,貌似是编译时时变成拓展了FunctionN特质的类，运行时变成类的实例，这个实例貌似就就是函数值，（函数值不是指函数的返回值）假设x是函数值，同时是拓展了特质Function1的类的实例，调用x(para：A)就可以调用函数
13:8.6结尾，为什么使用尾下划线，不懂
14:能创建闭包的函数叫开放项，闭包就是个函数值，不能的函数叫封闭项
15：高阶函数：以函数值为参数
16：无参函数有有副作用带括号，没副作用不带括号（类似占内存更小且更灵活的字段？）(统一访问原则)
17:字段和方法共享命名空间，字段能重写父类无参同名方法,同个类中字段和方法名不能相等 
18:scala命名空间，两个，（字段，方法，包，单例对象）（类和特质名）
19:在类的构造器中用val，可以同时定义同名的参数和字段，让构造类的参数可以有个同名字段提供对外访问,原先默认是private的。也可以是var和加修饰符,就是创建参数和字段，之后用参数给一个字段赋值
class (val a:Int,public var b:Int){} 等同于 class(para1:Int,para2:Int){val a=para1;publc var b=para2}
20:10.8首页底部：两个版本的方法互相重写？不能理解
21:没同名class，object是单例，有的话object内就是静态方法和成员(所以抽象类也能有伴生对象)？
22:让子类变成私有放入父类中是一种实现向客户端隐藏子类实现的方法
23：scalaObject特质 11.1结尾
24:类型匹配能匹配某个类的所有子类或是所有混合了某个特质的类吗？测试得出混合了Iterable类型的都可行
25:高低版本之间的创建对象方法有差异，比如2.8过后Queue是伴生对象和伴生类的实现，使用伴生类的工厂方法，创建用Queue[Int](),而之前用 new Queue[Int],再比如Set的**方法
26：scala数组不是协变的，而java是，协变会导致Object容器可以指向子类容器，但是同时因此可以接受其它子类的对象，最终导致ArrayStore异常。（当java有类型参数实现泛型后就不需要协变的数组了，但是考虑兼容问题仍然保留）
在scala和java代码转换时要解决这个问题，可以强行转换为超类数组val a1:Array[Object]=a2.asInstanceOf[Array[Object]]
27:new特质实际上创建了混合特质的匿名类

can't understand:
18.5
19.4
20.6调用的是子类方法，即使前面编译通过，后面调用子类方法时也能注入Animal所有子类？(JAVA重写也不能改参数为子类 )
21.5后面

my consider:
适合保证元素插入顺序的结构，貌似只有队列和栈？栈也许可以用数组实现，但是队列

special:
1:用for枚举时不用判断下标越界，以及强大的过滤等操作
2：函数代替字段，避免大型数据作为字段一直存放在内存中，需要时用函数调用获取数据，用完即可回收
3:继承Ordered特质只要实现compare定义什么是小于（或大于以及等于？），<,<=,>,>=，因为后三个可以直接用小于和现成的等于得出
4:把对象当作模块导入,避免调用对象属性还需要对象名作为前缀，导入模块后可以改名，防止名字重复
5：模式匹配的模式变量的识别方法：小写字母开始的简单名，可以用反引号括起来使 `以小写字母开始的简单名` 命名的常量正确地被识别为常量模式,又或者加上限定符前缀，如果有的话
6：forall2(2.13),map2(2.13),Application(变成了App)等在高版本都被删除了
7：注意！！-1tolong后仍是-1

第二次阅读：
scala
scala方法参数的类型都是val，无法被修改
scala没有const
方法调用要有明确调用者才能用空格
做参数的函数字面量只有一行并且只要一个参数，可以直接写函数
for循环枚举的值是val，无法改变
方法体内只有单行结果表达式的方法可以去掉花括号，同时也可以写在同一行
方法不写等号会默认返回Unit，丢弃方法体内的返回值
（）［］内部都只能容纳单行语句，多行只能用｛｝
伴生对象和伴生类一定要定义在同一个源文件
前缀操作符 + _ ！~，会被转化为unary_x的方法，只有这四个符号可以，顶多重写
后缀操作符就是无参方法
操作符根据首字母的比较决定优先级，
第五章有表
类内不是方法定义也不是字段定义的代码会被放入主构造器（构造函数）中
创建实例时解释器打印的是toString得到的内容
require方法在构造时检验参数
可以使用参数化字段（parameric field）来组合参数和字段，相当于定义一个字段，把位置上的参数复制给字段，超类构造器就在主构造器中调用
def this(params*) 定义辅助构造器，注意和java不同需要def，（问：辅助构造器能用参数化字段吗？应该不能），辅助构造器必须再去调用其他构造器，以主构造器结尾，即主构造器是唯一入口点
字段的初始化器会按照出现顺序放到主构造器中（问：假如需要另外一个字段的字段放到需要的字段前会怎么样？）
标识符（用于变量和方法等的命名？）：
  字母数字标识符（下划线或字母开头，后跟字母数字下划线，美元符号也算字母，但保留用于编译器生成的标识符）
  操作符标识符（操作符字符组成，数学符号Sm和其他符号So的unicode集），如::等标识符编译后会变成$colon$colon等内部名
  混合标识符，字母数字组成，后跟下划线加一个操作符，如一元的前缀操作符unary_+，还有myvar_=用于定义赋值操作符（编译器产生用于支持属性的）
  字面量标识符，反引号括起来，用来在scala调用被设为保留字的方法的，如Thread.`yield`
重载匹配模糊会跑出参考模糊的异常
隐式转换要定义在作用域内（21章补充）
第七章
scala内建控制结构很少，只有for，while，if，try，catch和函数调用。但是支持函数字面量
赋值语句返回unit，和java返回赋值结果不同
while结构是被称为循环而非表达式是因为它没有返回值
审视对while和var的使用
for对任何有合适签名的foreach方法的集合类有效，定义在Iterable特质中
for循环条件用小括号时，加入多个if过滤器，中间要加分号，花括号分行就不用（问：验证一下）
for循环的过滤器和迭代器之间可以不加分号
for循环还有流间变量绑定
for循环的yield放在子句和循环体之间，收集每次循环体的结果（问：结果都是array吗？）
throw也是有结果类型Nothing的表达式，写在在赋值语句末尾会在赋值前把异常抛出，实际上什么类型的返回值都不会有影响
scala不捕获检查型异常，用@throws注解声明throws
try-catch-finally也产生值，无异常try内返回的值，有异常被捕获catch块内的值，有异常未捕获无返回值，finally不影响返回值。有显式return语句的话finally的return值优先级最高。
scala去除了break和continue因为和函数字面量啮合得不是很好
变量作用域在花括号内，允许在嵌套结构中声明同名变量，会发生覆盖
第八章
scala除了允许私有方法来隐藏方法的消息，还允许将函数定义在方法中作为局部函数，并且可以使用外部函数的参数，嵌套及作用域规则同变量
函数值是扩展了FunctionN特质的类的实例
当函数字面量被当作参数时，有目标参数化（target typing），根据调用者的类型决定参数类型，可以在定义函数字面量时省略类型参数
每个参数出现一次可以用占位符语法，在解释器中每个_被变为x＄N，占位符也能用来定义函数字面量，且没有类型推断时要显式指定类型
下划线还可以用作代替某个函数的整个参数列表，如可以用来快速生成使用某个函数的函数字面量sum _ 如同(a, b) => sum(a, b)
闭包val，var，参数均可捕获
函数既不是函数字面量也不是函数值，函数应该是一个接收参数返回值的一个类似子程序的东西
函数字面量感觉更偏向于匿名函数值，或者叫做函数值字面量，与函数值一样实际上就是一个scala生成的混FunctionN特质类的实例。函数字面量实质上感觉是一个匿名类，在伴生对象上有apply方法，以=>为基准，左边是参数，右边是方法体，而函数值则是给类取了名并获得了类的实例的引用。
部分应用函数应该相当于是使用函数生成的混入FuntionN特质的类的实例。val add5 = add(_, 5)相当于生成了一个有伴生对象且伴生对象有方法为def apply(a: Int) = add(a, 5)的类的实例的引用，而 add _则是所有参数都用_代替的简写（函数名和下划线之间要有空格，不然可能会被编译器以为在调用add_方法）在需要函数值做参数的地方直接用函数名应该会自动转换为函数名 _形式的部分应用函数
调用时为数组添加_*类型参数可以把数组的元素当作一个一个参数
第九章
函数只有一个参数时才可以用花括号代替括号，可以在以函数作为参数的情况下显得更像控制结构
作为高阶函数，直接声明一个def add(a: Int)( b: Int):Int高阶函数得到的是高阶函数，类型为(Int)(Int)Int,如果使用字面量的形式定义一个变量，得到的类型是(Int)(Int) => Int，认为可以看作两部分，实际上是声明了一个函数，（Int)指代参数部分，剩下的就是返回值部分